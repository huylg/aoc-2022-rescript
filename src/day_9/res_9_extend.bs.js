// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Caml = require("rescript/lib/js/caml.js");
var Belt_Id = require("rescript/lib/js/belt_Id.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Js_string = require("rescript/lib/js/js_string.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_MutableSet = require("rescript/lib/js/belt_MutableSet.js");

var input = Belt_Array.map(Belt_Array.map(Belt_Array.keep(Fs.readFileSync("src/day_9/test", "utf8").split("\n"), (function (e) {
                return e !== "";
              })), (function (param) {
            return Js_string.split(" ", param);
          })), (function (line) {
        return [
                line[0],
                Belt_Int.fromString(line[1])
              ];
      }));

function cmp(a, b) {
  var c = Caml.int_compare(a.x, b.x);
  if (c !== 0) {
    return c;
  } else {
    return Caml.int_compare(a.y, b.y);
  }
}

var PairComparator = Belt_Id.MakeComparable({
      cmp: cmp
    });

var points = Belt_MutableSet.make(PairComparator);

var s = {
  x: 0,
  y: 0
};

var h = [s];

var t = [s];

function sumPoint(a, b) {
  return {
          x: a.x + b.x | 0,
          y: a.y + b.y | 0
        };
}

function cal_gap(a, b) {
  return [
          a.x - b.x | 0,
          a.y - b.y | 0
        ];
}

function last(a) {
  var len = a.length;
  return Belt_Array.get(a, len - 1 | 0);
}

Belt_Array.forEach(Belt_Array.flatMap(input, (function (param) {
            return Belt_Array.make(param[1], param[0]);
          })), (function (d) {
        var cur_h = last(h);
        var cur_t = last(t);
        var new_h;
        switch (d) {
          case "D" :
              new_h = sumPoint(cur_h, {
                    x: 0,
                    y: -1
                  });
              break;
          case "L" :
              new_h = sumPoint(cur_h, {
                    x: -1,
                    y: 0
                  });
              break;
          case "R" :
              new_h = sumPoint(cur_h, {
                    x: 1,
                    y: 0
                  });
              break;
          case "U" :
              new_h = sumPoint(cur_h, {
                    x: 0,
                    y: 1
                  });
              break;
          default:
            new_h = cur_h;
        }
        var gap = cal_gap(new_h, cur_t);
        var new_t;
        switch (gap[0]) {
          case -2 :
              switch (gap[1]) {
                case -1 :
                    new_t = sumPoint(cur_t, {
                          x: -1,
                          y: -1
                        });
                    break;
                case 0 :
                    new_t = sumPoint(cur_t, {
                          x: -1,
                          y: 0
                        });
                    break;
                case 1 :
                    new_t = sumPoint(cur_t, {
                          x: -1,
                          y: 1
                        });
                    break;
                default:
                  new_t = cur_t;
              }
              break;
          case -1 :
              var match = gap[1];
              new_t = match !== -2 ? (
                  match !== 2 ? cur_t : sumPoint(cur_t, {
                          x: -1,
                          y: 1
                        })
                ) : sumPoint(cur_t, {
                      x: -1,
                      y: -1
                    });
              break;
          case 0 :
              var match$1 = gap[1];
              new_t = match$1 !== -2 ? (
                  match$1 !== 2 ? cur_t : sumPoint(cur_t, {
                          x: 0,
                          y: 1
                        })
                ) : sumPoint(cur_t, {
                      x: 0,
                      y: -1
                    });
              break;
          case 1 :
              var match$2 = gap[1];
              new_t = match$2 !== -2 ? (
                  match$2 !== 2 ? cur_t : sumPoint(cur_t, {
                          x: 1,
                          y: 1
                        })
                ) : sumPoint(cur_t, {
                      x: 1,
                      y: -1
                    });
              break;
          case 2 :
              switch (gap[1]) {
                case -1 :
                    new_t = sumPoint(cur_t, {
                          x: 1,
                          y: -1
                        });
                    break;
                case 0 :
                    new_t = sumPoint(cur_t, {
                          x: 1,
                          y: 0
                        });
                    break;
                case 1 :
                    new_t = sumPoint(cur_t, {
                          x: 1,
                          y: 1
                        });
                    break;
                default:
                  new_t = cur_t;
              }
              break;
          default:
            new_t = cur_t;
        }
        h.push(new_h);
        t.push(new_t);
      }));

console.log(Belt_MutableSet.size(Belt_MutableSet.fromArray(t, PairComparator)));

exports.input = input;
exports.PairComparator = PairComparator;
exports.points = points;
exports.s = s;
exports.h = h;
exports.t = t;
exports.sumPoint = sumPoint;
exports.cal_gap = cal_gap;
exports.last = last;
/* input Not a pure module */
